set-flag print-var-sorts "off"
set-flag print-qvar-sorts "off"

load "NN-sum"
open NN-sum

module NN-times{
	
	#___Axioms
	declare times: [N N] -> N [*]
	assert* Times-zero := (x * zero = zero)
	assert* Times-nonzero := (x * S y = x * y + x)
	
	declare one: N
	assert one-definition := (one = S zero)
	
	#___PROPERTIES
	assert* zero-Times-property := (zero * x = zero)
	
	#___x*1=x
	define Times-right-one := (forall x . x * one = x)
	conclude Times-right-one
		pick-any x:N
		(!chain [ (x * one)
			= (x * ( S zero ))	[one-definition]
			= ((x * zero) +  x)	[Times-nonzero]
			= (zero + x)		[Times-zero]
			
			= x			[zero-Plus-property]])
	
	#___x*(y+z)=x*y+x*z
	define times-dist := (forall z x y . x * (y + z) = x * y + x * z)
	by-induction times-dist {
	zero => pick-any x y (
		!chain [(x * (y + zero))
			= (x * y)		[Plus-zero-axiom]
			= (x * y + zero)	[Plus-zero-axiom]
			= (x * y + x * zero)	[Times-zero]])
	| (S z) =>
		let {ind-hyp := (forall x y . x * (y + z) = x * y + x * z)}
		pick-any x y (
		!chain [( x * (y + (S z)))
			=(x * (S (y + z)))	[Plus-S-axiom]
			=(x * (y + z) + x)	[Times-nonzero]
			=((x * y + x * z) + x)	[ind-hyp]
			=(x * y + (x * z + x))	[associativity]
			=(x * y + x * S z)	[Times-nonzero]])		
	}
	
	#___x*y=y*x
	define times-commute := (forall x y . x * y = y * x)
	
	
	assert* times-commute
		
	#___x*(y*z)=(x*y)*z
	define times-associate := (forall z x y . ((x * y) * z) = (x * (y * z)))
	
	by-induction times-associate {
	zero => pick-any x y (
		!chain [((x * y) * zero)
			=(zero)			[Times-zero]
			=(x * zero)		[Times-zero]
			=(x * (y * zero))	[Times-zero]])
	| (S z) =>
		let {ind-hyp := (forall x y . ((x * y) * z) = (x * (y * z)))}
		pick-any x y (
		!chain [((x * y) * S z)
			=(((x * y) * z) + (x * y))	[Times-nonzero]
			=((x * (y * z)) + (x * y))	[ind-hyp]
			=((x * y) + (x * (y * z)))	[commutativity]
			=(x * (y + (y * z)))		[times-dist]
			=(x * ((y * z) + y))		[commutativity]
			=(x * (y * (S z)))		[Times-nonzero]])
	}
	
}





