set-flag print-var-sorts "off"
set-flag print-qvar-sorts "off"

load "NN-sum"
open NN-sum

module NN-times{
	
	#___Axioms
	declare times: [N N] -> N [*]
	assert* Times-zero := (x * zero = zero)
	assert* Times-nonzero := (x * S y = x * y + x)
	
	declare one: N
	assert one-definition := (one = S zero)
	
	#___PROPERTIES
	assert* zero-Times-property := (zero * x = zero)
	
	#___x*1=x
	define Times-right-one := (forall x . x * one = x)
	conclude Times-right-one
		pick-any x:N
		(!chain [ (x * one)
			= (x * ( S zero ))	[one-definition]
			= ((x * zero) +  x)	[Times-nonzero]
			= (zero + x)		[Times-zero]
			= x			[zero-Plus-property]])
			
	
	#___x*(y+z)=x*y+x*z
	define times-dist := (forall z x y . x * (y + z) = x * y + x * z)
	by-induction times-dist {
	zero => pick-any x y (
		!chain [(x * (y + zero))
			= (x * y)		[Plus-zero-axiom]
			= (x * y + zero)	[Plus-zero-axiom]
			= (x * y + x * zero)	[Times-zero]])
	| (S z) =>
		let {ind-hyp := (forall x y . x * (y + z) = x * y + x * z)}
		pick-any x y (
		!chain [( x * (y + (S z)))
			=(x * (S (y + z)))	[Plus-S-axiom]
			=(x * (y + z) + x)	[Times-nonzero]
			=((x * y + x * z) + x)	[ind-hyp]
			=(x * y + (x * z + x))	[associativity]
			=(x * y + x * S z)	[Times-nonzero]])		
	}
	
	#___x*y=y*x
	define times-commute := (forall x y . x * y = y * x)
	assert* times-commute
	
	#___x*(y*z)=(x*y)*z
	define times-associate := (forall x y z . (x * (y * z) = (x * y) * z))
	assert* times-associate
	
}





